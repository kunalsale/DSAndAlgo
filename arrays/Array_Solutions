Array:

Problem 1. Find the maximum value in an array where the elements are first increasing and then decreasing.

Input: Array of elements 
array : 6, 7, 10, 15, 14, 12, 11
Output: 15

Idea: Search the element for which the previous element is less and next element is greater.

Brute force:

Linear search:
1. Take a variable maxValue and assign Int.MIN_VALUE to it.
2. Iterate through the array from 0 to n - 1.
3. If maxValue is less than the array[currentIndex] then assign the maxValue = array[currentIndex]
4.return the maxValue.

Time complexity: O(n) as we are iterating entire array.
Space complexity: O(1)

Better solution:

Hint: As we know that array is increasing then the decreasing which means it is partially sorted. Hence we can use binary search here but need to modify it as in binary tree entire array has to be sorted.

Idea: 

There can be 3 kinds of element.
1. Element which is less than the right element and greater than the left element. eg: element 7 whose left is 6 and rigt is 10
2.  Element which is less than the left element and greater than the right element. eg: element 12 whose left is 14 and rigt is 11
3. Element which is greater than left as well as right and that is our element.

So, in binary search if we found an element in the increasing part then move the left pointer and if the element picked in the binary search is in the decreasing part then move the right pointer.


Corner case:

1. If there is only one element then return that element.
2. If there are two elements then return the max within them

Algo:

1. Check the corner cases.
2. Take two pointers low and high and assign low to the zero th index and high to n - 1.
3. Compute the mid index which will be (low + high) / 2
4. Check the above conditions and see where the element lies in the array.
	a. If it is in the increasing part then low = mid + 1
	b. If it is in the decreasing part then high = mid - 1
	c. if the element is greated than both the element then return the array[mid]

Time complexity: O(log n)
Space complexity: O(1)

---------------------------------------------------------------------------------------------

Problem 2: 
Find a number in a sorted array which is rotated.
What is Rotate array? Suppose we have an array which is sorted and with elements 1, 2, 3, 4, 5, 6. If we rotate the array by two slots or times then it will look like 3, 4, 5, 6, 1, 2. 

Input: 3, 4, 5, 6, 1, 2. element - 5
Output: 2 which is the index of the element and if it is not found then return -1

Approaches:

1. Linear approach can be used which will take O(n) time complexity.

2. Binary search approach.

Here, the array is rotated so there are two sorted array within entire array and binary search works efficiently in the sorted array.

Algorithm:

1. Pick an element which is a mid then check if it is the element which is to be searched and if yes then return.
2. If the element is less than the key element then check if the element is less or greater than the array[low] element.
	a. If it is less means it lies in the left sorted array then as the element is greater










